<!DOCTYPE html>
<html lang="{{ lang }}">
<head>
    <meta charset="UTF-8">
    <title>{{ 'battle'|trans }}</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
</head>
<body>
    <h1>{{ 'battle'|trans }}</h1>
    <div class="status-panel">
        <div class="character-status">
            <h2>{{ 'character'|trans }}: {{ character.name }}</h2>
            <p>{{ 'hp_label'|trans }} <span id="char_hp">{{ character.hp }}</span></p>
            <p>{{ 'speed'|trans }}: <span id="char_speed">30</span></p>
            <p>{{ 'spell_slots'|trans }}: <span id="spell_slots">{{ character.spell_slots }}</span></p>
            <!-- New Ability Scores Section -->
            <div class="ability-scores mt-2 text-sm text-gray-400">
                <h3 data-trans="ability_scores"></h3>
                <div class="flex space-x-4">
                    <div><span data-trans="strength"></span>: <span id="ability_strength">{{ character.ability_scores.strength }}</span></div>
                    <div><span data-trans="dexterity"></span>: <span id="ability_dexterity">{{ character.ability_scores.dexterity }}</span></div>
                    <div><span data-trans="constitution"></span>: <span id="ability_constitution">{{ character.ability_scores.constitution }}</span></div>
                    <div><span data-trans="intelligence"></span>: <span id="ability_intelligence">{{ character.ability_scores.intelligence }}</span></div>
                    <div><span data-trans="wisdom"></span>: <span id="ability_wisdom">{{ character.ability_scores.wisdom }}</span></div>
                    <div><span data-trans="charisma"></span>: <span id="ability_charisma">{{ character.ability_scores.charisma }}</span></div>
                </div>
            </div>
        </div>
        <div class="enemy-status">
            <h2>{{ 'enemy'|trans }}: {{ enemy.name|trans }}</h2>
            <p>{{ 'hp_label'|trans }} <span id="enemy_hp">{{ enemy.hp }}</span></p>
        </div>
    </div>
    
    <!-- Canvas to draw a hexagonal battle grid -->
    <canvas id="hexCanvas" width="800" height="600"></canvas>
    <br>
    
    <!-- Unified controls section -->
    <div class="controls">
        <div class="movement-controls">
            <button id="applyMoveButton">{{ 'apply_move'|trans }}</button>
            <button id="endTurnButton">{{ 'end_turn'|trans }}</button>
        </div>
        <div class="combat-controls">
            <div class="attack-options">
                <h3>{{ 'choose_attack'|trans }}:</h3>
                <button 
                    data-spell-type="spell"
                    data-range="1"
                    data-spell-name="Melee Attack"
                    class="attack-button spell-btn">
                    {{ 'melee_attack'|trans }} ({{ 'range'|trans }}: 1)
                </button>
                
                <h3>{{ 'available_spells'|trans }}:</h3>
                <div class="spell-buttons">
                    <h4>{{ 'level_1_spells'|trans }}</h4>
                    {% for spell_name, spell_data in spells_1lvl.items() %}
                    <button 
                        data-spell-type="spell"
                        data-range="{{ spell_data.range }}"
                        data-spell-name="{{ spell_name }}"
                        class="attack-button spell-btn">
                        {{ spell_name|trans }} ({{ 'range'|trans }}: {{ spell_data.range }} {{ 'tiles'|trans }})
                    </button>
                    {% endfor %}
                    
                    <h4>{{ 'level_2_spells'|trans }}</h4>
                    {% for spell_name, spell_data in spells_2lvl.items() %}
                    <button 
                        data-spell-type="spell"
                        data-range="{{ spell_data.range }}"
                        data-spell-name="{{ spell_name }}"
                        class="attack-button spell-btn">
                        {{ spell_name|trans }} ({{ 'range'|trans }}: {{ spell_data.range }} {{ 'tiles'|trans }})
                    </button>
                    {% endfor %}
                </div>
            </div>
            <div class="action-buttons">
                <button id="attackButton" disabled>{{ 'attack'|trans }}</button>
                <button id="castSpellButton" disabled>{{ 'cast_spell'|trans }}</button>
            </div>
            <div id="attackPreview" style="display:none;"></div>
            <div id="diceControls" style="display:none;">
                <button id="rollHitButton">{{ 'roll_hit'|trans }} (d20)</button>
                <button id="rollDamageButton" style="display:none;">{{ 'roll_damage'|trans }} (d6)</button>
            </div>
        </div>
    </div>
    
    <div class="battle-log">
        <h3>{{ 'battle_log'|trans }}:</h3>
        <div id="battleLog" style="border:1px solid #000; padding: 10px; width: 800px; height: 300px; overflow-y: scroll;"></div>
    </div>
    
    <!-- Add instruction for movement -->
    <br>
    <p id="instructions">{{ 'movement_instructions'|trans }}</p>
    
    <style>
    .spell-level {
        margin-bottom: 20px;
    }

    .spell-card {
        border: 1px solid #ddd;
        border-radius: 8px;
        padding: 10px;
        margin: 5px;
        background-color: white;
        width: 200px;
        display: inline-block;
        vertical-align: top;
    }

    .spell-details {
        font-size: 0.9em;
        color: #666;
        margin-top: 5px;
    }

    .spell-button {
        width: 100%;
        padding: 8px;
        margin-bottom: 5px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-weight: bold;
    }

    .level-1 {
        background-color: #e3f2fd;
        color: #1565c0;
    }

    .level-2 {
        background-color: #fff3e0;
        color: #ef6c00;
    }

    .spell-button:hover {
        filter: brightness(0.9);
    }

    .spell-button:disabled {
        background-color: #ccc;
        cursor: not-allowed;
    }

    .attack-button {
        display: block;
        width: 100%;
        padding: 10px;
        margin: 5px 0;
        background-color: #4CAF50;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        text-align: left;
    }

    .attack-button:hover {
        background-color: #45a049;
    }

    .attack-button:disabled {
        background-color: #cccccc;
        cursor: not-allowed;
    }

    h4 {
        margin: 15px 0 5px 0;
    }
    </style>
    
    <script src="{{ url_for('static', filename='js/hexgrid.js') }}"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Обработчик только для кнопок заклинаний
            document.querySelectorAll('.spell-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    selectAttack(
                        this.dataset.spellType,
                        parseInt(this.dataset.range),
                        this.dataset.spellName
                    );
                });
            });
        });
        
        // Draw initial hex grid
        drawHexGrid();
        
        // Global variables for attack options and state
        let playerActionTaken = false;
        let selectedAttack = null;
        let attackRange = 0;
        let pendingHitRoll = null;
        let pendingDamageRoll = null;
        let movementTaken = false;

        // Global variables for storing selected spell
        let selectedSpellName = null;
        let selectedSpellData = null;

        // Global variables for target selection
        let selectedSpellTarget = null;
        let waitingForSpellTarget = false;

        // Define grid dimensions for the hex grid
        const gridCols = 10;
        const gridRows = 8;

        // Добавим функцию для удаления обработчиков
        function removeMouseMoveHandlers() {
            canvas.removeEventListener("mousemove", handleSpellAreaPreview);
        }

        // Создадим отдельную функцию для обработки перемещения мыши
        function handleSpellAreaPreview(e) {
            let cell = getCellFromPixel(e.clientX, e.clientY);
            if (cell) {
                clearHighlight();
                
                if (selectedSpellName === "Misty Step") {
                    // Подсвечиваем точку телепортации
                    highlightCell(cell.col, cell.row, 'rgba(0, 255, 255, 0.5)');
                    selectedSpellTarget = cell;
                    document.getElementById("castSpellButton").disabled = false;
                    return;
                }
                
                let distanceToTarget = Math.sqrt(
                    Math.pow(cell.col - playerPos.col, 2) + 
                    Math.pow(cell.row - playerPos.row, 2)
                );
                
                if (distanceToTarget <= attackRange) {
                    switch(selectedSpellName) {
                        case "Ice Knife":
                        case "Cloud of Daggers":
                        case "Burning Hands":
                            highlightArea3x3(cell, 'rgba(255, 0, 0, 0.3)');
                            break;
                            
                        case "Chromatic Orb":
                        case "Dragon's Breath":
                            highlightRadius(cell, 2, 'rgba(255, 0, 0, 0.3)');
                            break;
                            
                        case "Shatter":
                            highlightRadius(cell, 1, 'rgba(255, 0, 0, 0.3)');
                            break;
                            
                        case "Magic Missile":
                        case "Hold Person":
                        case "Scorching Ray":
                            highlightCell(cell.col, cell.row, 'rgba(255, 0, 0, 0.3)');
                            break;
                        case "Melee Attack":
                            highlightCell(cell.col, cell.row, 'rgba(255, 0, 0, 0.3)');
                            selectedSpellTarget = cell;
                            document.getElementById("castSpellButton").disabled = false;
                            break;
                    }
                }
            }
        }

        // Updated highlightCell function to draw a hexagon overlay with given color
        function highlightCell(col, row, color = 'rgba(255, 255, 0, 0.3)') {
            let ctx = canvas.getContext("2d");
            let hexSize = 30;
            let hexWidth = hexSize * 2;
            let hexHeight = Math.sqrt(3) * hexSize;
            let x = col * hexWidth * 0.75 + hexSize;
            let y = row * hexHeight + ((col % 2) * hexHeight / 2) + hexSize;
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
                let angle = Math.PI / 3 * i; // 60 degree intervals
                let xi = x + hexSize * Math.cos(angle);
                let yi = y + hexSize * Math.sin(angle);
                if (i === 0) {
                    ctx.moveTo(xi, yi);
                } else {
                    ctx.lineTo(xi, yi);
                }
            }
            ctx.closePath();
            ctx.fillStyle = color;
            ctx.fill();
            ctx.strokeStyle = 'black';
            ctx.stroke();
        }

        function highlightArea3x3(center, color = 'rgba(255, 255, 0, 0.3)') {
            for (let col = center.col - 1; col <= center.col + 1; col++) {
                for (let row = center.row - 1; row <= center.row + 1; row++) {
                    if (col >= 0 && col < gridCols && row >= 0 && row < gridRows) {
                        highlightCell(col, row, color);
                    }
                }
            }
        }

        function highlightRadius(center, radius, color = 'rgba(255, 255, 0, 0.3)') {
            for (let col = 0; col < gridCols; col++) {
                for (let row = 0; row < gridRows; row++) {
                    let distance = Math.sqrt(
                        Math.pow(col - center.col, 2) + 
                        Math.pow(row - center.row, 2)
                    );
                    if (distance <= radius) {
                        highlightCell(col, row, color);
                    }
                }
            }
        }

        // Обновим функцию highlightSpellArea
        function highlightSpellArea(spellName, range) {
            clearHighlight();
            removeMouseMoveHandlers();
            
            // Для Healing Word сразу активируем кнопку
            if (spellName === "Healing Word") {
                document.getElementById("castSpellButton").disabled = false;
                return;
            }
            
            // Для всех заклинаний, требующих выбора цели, добавляем обработчик
            if (["Ice Knife", "Cloud of Daggers", "Chromatic Orb", "Scorching Ray", 
                 "Shatter", "Dragon's Breath", "Hold Person", 
                 "Magic Missile", "Burning Hands", "Thunderwave", "Melee Attack"].includes(spellName)) {
                canvas.addEventListener("mousemove", handleSpellAreaPreview);
            } else {
                // Для заклинаний с фиксированной областью
                switch(spellName) {
                    case "Thunderwave":
                        highlightArea3x3({col: playerPos.col, row: playerPos.row}, 'rgba(255, 0, 0, 0.3)');
                        document.getElementById("castSpellButton").disabled = false;
                        break;
                    default:
                        highlightRange(range);
                }
            }
        }

        // Updated selectAttack function already calls highlightRange or highlightSpellArea as needed
        function selectAttack(type, range, spellName = null) {
            console.log("Selected attack:", type, range, spellName); // Для отладки
            
            selectedAttack = type;
            attackRange = range;
            selectedSpellName = spellName;
            
            // Только для заклинаний
            selectedSpellData = {
                name: spellName,
                range: range
            };
            highlightSpellArea(spellName, range);
            document.getElementById("castSpellButton").disabled = true;
            document.getElementById("attackButton").disabled = true;
            waitingForSpellTarget = true;
            document.getElementById("attackPreview").innerText = 
                `Selected spell: ${spellName} (Range: ${range} tiles). Click on target location.`;
            
            document.getElementById("attackPreview").style.display = "block";
        }

        function highlightAllExceptPlayer() {
            for (let col = 0; col < gridCols; col++) {
                for (let row = 0; row < gridRows; row++) {
                    if (col !== playerPos.col || row !== playerPos.row) {
                        highlightCell(col, row);
                    }
                }
            }
        }

        // Add message to battle log
        function addToBattleLog(message) {
            let logDiv = document.getElementById("battleLog");
            logDiv.innerHTML += "<p>" + message + "</p>";
            logDiv.scrollTop = logDiv.scrollHeight;
        }
        
        // Update the speed display
        function updateSpeedDisplay() {
            document.getElementById("char_speed").innerText = playerSpeed;
        }

        // Clear attack selection and reset controls
        function clearAttackSelection() {
            selectedAttack = null;
            selectedSpellName = null;
            selectedSpellData = null;
            selectedSpellTarget = null;
            waitingForSpellTarget = false;
            attackRange = 0;
            removeMouseMoveHandlers();
            document.getElementById("attackPreview").style.display = "none";
            document.getElementById("diceControls").style.display = "none";
            document.getElementById("attackButton").disabled = true;
            document.getElementById("castSpellButton").disabled = true;
            document.getElementById("rollHitButton").disabled = false;
            document.getElementById("rollDamageButton").disabled = false;
            clearHighlight();
        }

        // Roll Hit button handler
        document.getElementById("rollHitButton").addEventListener("click", function() {
            if (this.disabled) return;
            
            fetch("/api/roll_dice", {
                method: "POST",
                body: new URLSearchParams({sides: 20})
            })
            .then(response => response.json())
            .then(data => {
                pendingHitRoll = data.result;
                addToBattleLog("Hit roll: " + pendingHitRoll);
                this.disabled = true;
                if (pendingHitRoll >= 10) {
                    document.getElementById("rollDamageButton").style.display = "inline-block";
                } else {
                    addToBattleLog("Your attack would miss.");
                    setTimeout(() => {
                        clearAttackSelection();
                    }, 1500);
                }
            });
        });

        // Roll Damage button handler
        document.getElementById("rollDamageButton").addEventListener("click", function() {
            if (this.disabled) return;
            
            fetch("/api/roll_dice", {
                method: "POST",
                body: new URLSearchParams({sides: 6})
            })
            .then(response => response.json())
            .then(data => {
                pendingDamageRoll = data.result;
                addToBattleLog("Damage roll: " + pendingDamageRoll);
                this.disabled = true;
                
                // Automatically perform the attack after rolling damage
                let formData = new FormData();
                formData.append("hit_roll", pendingHitRoll);
                formData.append("damage_roll", pendingDamageRoll);
                
                if (selectedAttack === 'melee') {
                    fetch("/api/attack", {method: "POST", body: formData})
                    .then(response => response.json())
                    .then(data => {
                        updateBattleStatus(data);
                        playerActionTaken = true;
                        clearAttackSelection();
                    });
                } else if (selectedAttack === 'magic') {
                    formData.append("spell", "Magic Missile");
                    fetch("/api/cast_spell", {method: "POST", body: formData})
                    .then(response => response.json())
                    .then(data => {
                        updateBattleStatus(data);
                        playerActionTaken = true;
                        clearAttackSelection();
                    });
                }
            });
        });

        // Apply Move button handler
        document.getElementById("applyMoveButton").addEventListener("click", function() {
            clearAttackSelection();
            applyMove();
            updateSpeedDisplay();
        });

        // Attack button handler
        document.getElementById("attackButton").addEventListener("click", function() {
            if (playerActionTaken) {
                addToBattleLog("You have already attacked this turn!");
                return;
            }
            if (!isInRange(enemyPos.col, enemyPos.row, attackRange)) {
                addToBattleLog("Enemy is not in range!");
                return;
            }
            
            if (selectedAttack === 'melee') {
                // Show dice controls for melee attack
                document.getElementById("diceControls").style.display = "block";
                document.getElementById("rollHitButton").style.display = "inline-block";
                document.getElementById("rollDamageButton").style.display = "none";
                document.getElementById("attackButton").disabled = true;
            }
        });

        // Cast Spell button handler
        document.getElementById("castSpellButton").addEventListener("click", function() {
            if (playerActionTaken) {
                addToBattleLog("You have already acted this turn!");
                return;
            }
            
            fetch("/api/cast_spell", {
                method: "POST",
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    spell_name: selectedSpellName,
                    spell_data: selectedSpellData,
                    target: selectedSpellTarget || {
                        col: enemyPos.col,
                        row: enemyPos.row
                    }
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    addToBattleLog(data.error);
                    return;
                }
                updateBattleStatus(data);
                
                // Обновляем позицию игрока если это был Misty Step
                if (data.player_pos) {
                    playerPos.col = data.player_pos.col;
                    playerPos.row = data.player_pos.row;
                    updateGrid();
                }
                
                playerActionTaken = true;
                clearAttackSelection();
            });
        });

        // End Turn button handler
        document.getElementById("endTurnButton").addEventListener("click", function() {
            clearAttackSelection();
            playerSpeed = 30;
            updateSpeedDisplay();
            playerActionTaken = false;
            movementTaken = false;
            
            let formData = new FormData();
            formData.append("player_col", playerPos.col);
            formData.append("player_row", playerPos.row);
            fetch("/api/enemy_attack", {method: "POST", body: formData})
            .then(response => response.json())
            .then(data => {
                updateBattleStatus(data);
                if (data.enemy_pos) {
                    enemyPos.col = data.enemy_pos.col;
                    enemyPos.row = data.enemy_pos.row;
                    updateGrid();
                }
            });
        });

        function updateBattleStatus(data) {
            if (data.combat_log) {
                addToBattleLog(data.combat_log);
            }
            if (data.character_hp !== undefined) {
                let hp = Number(data.character_hp);
                document.getElementById("char_hp").innerText = hp;
                if (hp <= 0) {
                    addToBattleLog("You have been defeated!");
                    endBattle(false);
                }
            }
            if (data.enemy_hp !== undefined) {
                let hp = Number(data.enemy_hp);
                document.getElementById("enemy_hp").innerText = hp;
                if (hp <= 0) {
                    addToBattleLog("Enemy defeated!");
                    endBattle(true);
                }
            }
        }

        function endBattle(victory) {
            // Disable all controls
            document.querySelectorAll('button').forEach(btn => btn.disabled = true);
            
            // Show victory/defeat message
            const message = victory ? "Victory! Battle ended." : "Defeat! Battle ended.";
            addToBattleLog(message);
            
            // Optional: Add a button to return to main screen
            const returnButton = document.createElement('button');
            returnButton.innerText = "Return to Main Screen";
            returnButton.onclick = () => window.location.href = '/';
            document.body.appendChild(returnButton);
        }

        // New function to update the grid and persistently highlight the selected target
        function updateGrid() {
            drawHexGrid();
            if (selectedSpellTarget) {
                highlightTargetEffect(selectedSpellTarget);
            }
        }

        // Replace call in the canvas mousemove handler
        canvas.addEventListener("mousemove", function(e) {
            if (!drawingPath) return;
            let cell = getCellFromPixel(e.clientX, e.clientY);
            if (cell) {
                currentPath = computePath(playerPos, cell);
                updateGrid();
                // Показываем только длину пути без проверки скорости
                let steps = currentPath.length - 1;
                let canvas = document.getElementById("hexCanvas");
                let ctx = canvas.getContext("2d");
                ctx.fillStyle = "green";
                ctx.font = "14px Arial";
                ctx.fillText(`Path: ${steps} tiles`, 10, 20);
            }
        });

        // In the applyMove function, replace drawHexGrid() with updateGrid()
        function applyMove() {
            if (movementTaken) {
                addToBattleLog("You have already moved this turn!");
                return;
            }
            if (currentPath.length < 2) {
                alert("No path selected!");
                return;
            }
            let dest = currentPath[currentPath.length - 1];
            if (dest.col === enemyPos.col && dest.row === enemyPos.row) {
                alert("Cannot move onto enemy's square!");
                return;
            }
            let steps = currentPath.length - 1;
            // Проверяем активен ли Misty Step
            if (selectedSpellName === "Misty Step") {
                // Если Misty Step активен - двигаемся без ограничений
                playerPos.col = dest.col;
                playerPos.row = dest.row;
                currentPath = [];
                movementTaken = true;
                updateGrid();
                addToBattleLog(`Teleported ${steps} tiles with Misty Step!`);
            } else {
                // Обычное движение с ограничением скорости
                let maxSteps = Math.floor(playerSpeed / 5);
                if (steps > maxSteps) {
                    alert(`Cannot move more than ${maxSteps} tiles with current speed (${playerSpeed})!`);
                    return;
                }
                let moveCost = steps * 5;
                playerSpeed -= moveCost;
                playerPos.col = dest.col;
                playerPos.row = dest.row;
                currentPath = [];
                movementTaken = true;
                updateGrid();
                updateSpeedDisplay();
                addToBattleLog(`Moved ${steps} tiles. Speed remaining: ${playerSpeed}`);
            }
        }

        function highlightRange(range) {
            clearHighlight();
            // Подсвечиваем все клетки в пределах радиуса действия
            for (let col = 0; col < gridCols; col++) {
                for (let row = 0; row < gridRows; row++) {
                    if (isInRange(col, row, range)) {
                        highlightCell(col, row);
                    }
                }
            }
        }

        // Обновим обработчик клика по canvas
        canvas.addEventListener("click", function(e) {
            if (waitingForSpellTarget) {
                let cell = getCellFromPixel(e.clientX, e.clientY);
                if (cell) {
                    selectedSpellTarget = cell;
                    addToBattleLog(`Target selected at (${cell.col}, ${cell.row})`);
                    // Visual cue for the impacted area
                    highlightTargetEffect(cell);
                    document.getElementById("castSpellButton").disabled = false;
                }
            }
        });

        // New function to highlight the target effect area based on the selected spell
        function highlightTargetEffect(cell) {
            if (!selectedSpellName) return;
            switch(selectedSpellName) {
                case "Ice Knife":
                case "Cloud of Daggers":
                case "Burning Hands":
                    highlightArea3x3(cell, 'rgba(255, 0, 0, 0.5)');
                    break;
                case "Chromatic Orb":
                case "Dragon's Breath":
                    highlightRadius(cell, 2, 'rgba(255, 0, 0, 0.5)');
                    break;
                case "Shatter":
                    highlightRadius(cell, 1, 'rgba(255, 0, 0, 0.5)');
                    break;
                case "Magic Missile":
                case "Hold Person":
                case "Scorching Ray":
                    highlightCell(cell.col, cell.row, 'rgba(255, 0, 0, 0.5)');
                    break;
                default:
                    highlightCell(cell.col, cell.row, 'rgba(255, 0, 0, 0.5)');
            }
        }
    </script>
</body>
</html> 