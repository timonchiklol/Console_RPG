{% extends "en/base.html" %}

{% block title %}Game{% endblock %}

{% block content %}
{% raw %}
<div id="game-app" v-cloak class="container mx-auto p-4">
  <!-- Header: Show Room Code and Save/Load buttons -->
  <div class="flex justify-between items-center mb-4">
    <div>
      <span class="medieval text-xl">Room Code: {{ room.room_id }}</span>
    </div>
    <div class="space-x-2">
      <button @click="saveGame" class="bg-green-700 hover:bg-green-600 px-4 py-2 rounded-lg medieval">Save Game</button>
      <button @click="loadGame" class="bg-blue-700 hover:bg-blue-600 px-4 py-2 rounded-lg medieval">Load Game</button>
      <button @click="leaveRoom" class="bg-gray-700 hover:bg-gray-600 px-4 py-2 rounded-lg medieval">Leave Room</button>
    </div>
  </div>

  <!-- Players in Room Section -->
  <div class="mb-4 bg-gray-800 p-4 rounded-lg">
    <h2 class="medieval text-2xl text-white mb-2">Players in Room</h2>
    <ul class="text-white">
      <li v-for="(player, pid) in room.players" :key="pid" class="mb-1">
        <strong>{{ player.name }}</strong> - Race: {{ player.race }}, Class: {{ player.class_name }}, Level: {{ player.level }}
      </li>
    </ul>
  </div>

  <!-- Character Stats Section -->
  <div class="mb-4">
    <h2 class="medieval text-2xl">Character Stats</h2>
    <p>Race: {{ gameState.race }}, Class: {{ gameState.class_name }}</p>
    <p>Level: {{ gameState.level }}, HP: {{ gameState.health_points }}, Damage: {{ gameState.damage }}</p>
    <p>Gold: {{ gameState.gold }}, Magic: {{ gameState.magic_1lvl }}/{{ gameState.magic_2lvl }}</p>
  </div>

  <!-- Messages Section -->
  <div class="mb-4">
    <h2 class="medieval text-2xl">Messages</h2>
    <div class="h-60 overflow-y-auto bg-gray-700 p-2 rounded-lg">
      <div v-for="msg in messages" :key="msg.id" class="mb-2">
        <span v-if="msg.type === 'system'" class="text-yellow-400">System: {{ msg.message }}</span>
        <span v-else-if="msg.type === 'dm'" class="text-green-400">DM: {{ msg.message }}</span>
        <span v-else class="text-blue-400">{{ msg.player_name }}: {{ msg.message }}</span>
      </div>
    </div>
  </div>

  <!-- Action Input Section -->
  <div class="mb-4">
    <input v-model="userInput" placeholder="Enter your action" class="px-4 py-2 rounded-lg bg-gray-700 text-white w-full" @keyup.enter="sendMessage">
  </div>
  <div class="mb-4">
    <button @click="sendMessage" :disabled="isLoading"
            :class="['w-full', 'bg-red-700', isLoading ? 'opacity-50 cursor-not-allowed' : 'hover:bg-red-600', 'px-4', 'py-2', 'rounded-lg', 'medieval']">
      Send Action
    </button>
  </div>

  <!-- Dice Roll Popup Modal -->
  <div v-if="diceNeeded" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center">
    <div class="bg-gray-800 rounded-lg p-6 max-w-md w-full">
      <h3 class="medieval text-2xl mb-4">Dice Roll Required</h3>
      <p class="mb-4">Please roll a {{ diceType }}.</p>
      <button @click="rollDice" :disabled="diceRolling" class="w-full bg-purple-700 hover:bg-purple-600 px-4 py-2 rounded-lg medieval">
        Roll {{ diceType }}
      </button>
    </div>
  </div>
</div>

<script>
const { createApp } = Vue;

createApp({
  data() {
    return {
      gameState: {},
      messages: [],
      userInput: '',
      isLoading: false,
      diceNeeded: false,
      diceType: 'd20',
      room: {},
      diceRolling: false
    };
  },
  methods: {
    async sendMessage() {
      if (!this.userInput.trim()) return;
      this.isLoading = true;
      try {
        const response = await fetch('/game_action', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ action: this.userInput })
        });
        const data = await response.json();
        if (data.error) {
          alert(data.error);
        } else {
          this.gameState = data.player;
          if (data.room) {
            this.room = data.room;
          }
          if (data.dice_needed) {
            this.diceNeeded = true;
            this.diceType = data.dice_type || 'd20';
          } else {
            this.diceNeeded = false;
          }
          if (data.messages) {
            this.messages = data.messages;
          }
          this.userInput = '';
        }
      } catch (e) {
        console.error(e);
      }
      this.isLoading = false;
    },
    async rollDice() {
      if (this.diceRolling) return;
      this.diceRolling = true;
      try {
        const rollResponse = await fetch('/roll_dice', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ dice_type: this.diceType })
        });
        const rollData = await rollResponse.json();
        if (rollData.error) {
          alert(rollData.error);
          return;
        }
        const processResponse = await fetch('/process_roll', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ roll: rollData.roll, dice_type: rollData.dice_type })
        });
        const processData = await processResponse.json();
        if (processData.error) {
          alert(processData.error);
        } else {
          this.gameState = processData.player;
          if (processData.messages) {
            this.messages = processData.messages;
          }
        }
      } catch (e) {
        console.error(e);
      } finally {
        this.diceNeeded = false;
        this.diceRolling = false;
      }
    },
    async saveGame() {
      try {
        const response = await fetch('/save_game', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' }
        });
        const data = await response.json();
        alert(data.message);
      } catch (e) {
        console.error(e);
      }
    },
    async loadGame() {
      try {
        const response = await fetch('/load_game', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' }
        });
        const data = await response.json();
        if (data.status === 'success') {
          this.gameState = data.room;
          alert(data.message);
        } else {
          alert(data.error || data.message || 'Error loading game');
        }
      } catch (e) {
        console.error(e);
      }
    },
    async leaveRoom() {
      if (!confirm("Are you sure you want to leave the room?")) return;
      try {
        const response = await fetch('/leave_room', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' }
        });
        const data = await response.json();
        if (data.status === 'success') {
          window.location.href = '/';
        } else {
          alert(data.message || 'Failed to leave room.');
        }
      } catch (e) {
        console.error(e);
      }
    },
    async loadInitialState() {
      try {
        const response = await fetch('/get_room_state');
        const data = await response.json();
        if (data.status === 'success') {
          this.gameState = data.room;
          this.messages = data.messages || [];
          this.room = data.room;
        }
      } catch (e) {
        console.error(e);
      }
    }
  },
  mounted() {
    this.loadInitialState();
  }
}).mount('#game-app');
</script>
{% endraw %}
{% endblock %} 